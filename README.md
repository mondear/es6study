- 第一章 ES6简介
	- ECMAScript是JavaScript的规格，后者是前者的实现。
- 第二章 let和const
	- let与var一样为声明变量，但是let的作用域为所在代码块。
	- 初略的理解为{}中。
	- for循环中let只在循环中能够使用
	- let不会发生变量提升
	- let/const存在暂时性死区
		- 在一个块中，如果在声明let/const之前使用了变量，那么直接报错。
		- typeof在这里达不到百分百安全，let变量在声明前会发生错误
		- typeof在检测一个没有声明的变量时显示undefined，与let不同
		- function默认参数为let（可能～），如果参数为x=y,y=1就会发生死区，因为y在使用前没有声明。
	- let不能在作用域内重复声明，也就意味着函数参数不能从新声明（在函数内部）。
	- es6的作用域：
		- 全局
		- 函数
		- 块级
	- 无块级作用域缺点：
		- 内层变量覆盖外层变量
		- 用于计数的循环变了变为全局变量
	- 块级作用域可以任意嵌套
	- 块级作用域可以替代立即执行的匿名函数
	- es5严格声明中函数只能在顶层作用域和函数作用域中声明
	- 严格模式
		- ‘use strict’
	- es6中，块级作用域中定义的函数为let声明，块级作用域中声明的函数不能在块以外调用
		- 在不同实现下有差异，所以尽量避免块中声明函数
		- 如果需要应该写成函数表达式
	- const为常量
	- const必须初始化
	- const不提升
	- 不可重复声明
	- 对于复合变量，const只是不能改变指向数据的地址，地址内的数据可以改变
	- 冻结对象
		- const foo = Object.freeze({})
		- 这种方法只是对对象本身冻结，还需要对属性也一起冻结
	- es6声明方式：
		- var
		- let
		- const
		- import
		- class
		- function
	- node中全局对象为global，浏览器中为windows
	- es6中，var和function声明的变量依然为全局对象的属性，let／const／class声明的全局变量不再进入全局属性中
